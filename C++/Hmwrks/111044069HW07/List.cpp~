/* 
 * File:   List.cpp
 * Author: Ramazan SAKIN -- 111044069
 */
#include<iostream>
#include "List.h"
#include "SortedList.h"

using namespace std;

namespace sakinSpace{    

template<class T>
List<T>::List() :numberOfElements(0){
    elements = new T[20];
}

template<class T>
List<T>::List( const T& array, const int numOfElement ):numberOfElements(numOfElement){
    for( int i=0; i<numOfElement; ++i )
        elements[i] = array[i];
}

template<class T>
List<T>::~List(){
    delete [] elements;    
}


template<class T>   //assignment operator for big three
List<T>& List<T>::operator=( const List<T>& otherList ){
    if( getNumberOfElements() != otherList.getNumberOfElements() ){
        delete [] elements;
        elements = new T[otherList.getNumberOfElements()];
        
    }
    setNumberOfElement( otherList.getNumberOfElements() );
    
    for( int i=0; i<otherList.getNumberOfElements(); ++i )
        elements[i] = otherList.getAnElementB(i);
        
    return *this;    
}

//copy-constructor
template<class T>
List<T>::List(const List<T>& orig) :numberOfElements(orig.numberOfElements){
    for( int i=0 ; i< getNumberOfElements(); ++i ){
        elements[i] = orig.getAnElementB(i);
    }
}

template<class T>
//The function can throw an exception ... ( exception specification ) )
T List<T>::getAnElementB(int index)const throw(int){
    if( index < 0 || index > getNumberOfElements() ){
        cout << "Illegal index!!!" << endl;
        throw index;
    }else
        return elements[index];       // first element of the array is elements[0]
}


template<class T>
//stream extraction operator
ostream& operator<<( ostream& out, const List<T>& aList ){
    int i;
    out << "Number of elements of the array of the list: "<< aList.getNumberOfElements()
                                                                               <<endl;    
    out << "The elements are :" << endl;
    for( i=0; i<aList.getNumberOfElements(); ++i )
        out << aList.getAnElementB(i) << " ";
    
    out << endl << endl;
    return out;
}

//overloading binary + operator for combining two List
template<class T>
List<T>& operator+( const List<T>& firstList , const List<T>& secondList )
{
    T anArray[firstList.getNumberOfElements()+secondList.getNumberOfElements()];
    int i;
    for( i=0 ; i<firstList.getNumberOfElements(); ++i )
        anArray[i] = firstList.getAnElementB(i);
    int k=0;
    for( int j=i; j<i+secondList.getNumberOfElements();++j ){
        anArray[j] = secondList.getAnElementB(k);
        ++k;
    }    
    return List<T>( anArray,firstList.getNumberOfElements()+secondList.getNumberOfElements());
}

//overloading % operator for taking intersection elements of two List
template<class T>
List<T>& operator%( const List<T>& firstList , const List<T>& secondList ){
    
    int lBorder, times=0, hBorder ;   //times is the number of integers elements of them
    if( firstList.getNumberOfElements() > secondList.getNumberOfElements() ){
        lBorder = secondList.getNumberOfElements();       //border is the number of less elements
        hBorder = firstList.getNumberOfElements();        
    }else{
        lBorder = firstList.getNumberOfElements();
        hBorder = secondList.getNumberOfElements();
    }
    
    T interSectionArray[lBorder];

    for( int k=0; k<hBorder; ++k ){
        if( firstList.getNumberOfElements() == lBorder && k == lBorder )
            break;
        bool status = secondList.searchAnElement(firstList.getAnElementB(k));
        if( status == true ){
            interSectionArray[times] = firstList.getAnElementB(k);
            ++times;
        }
    }
    
    return List<T>( interSectionArray, times );
}


}